Загрузка карты:
Загружаем файл map.json со свойствами карты и тайлами (тут все понятно)
Загружаем файлы buildings.json и entities.json с объектами
Каждый из файлов содержит список объектов карты и их свойств.
Свойства:
 - template - название шаблона объекта. Шаблон берется из папки
 templates и лежит в файле ${template}.json. В шаблоне описаны характеристики
 по-умолчанию для данного типа объекта. Конкретный экземпляр может
 переписать характеристики шаблона.
 Хотим загружать шаблоны по мере необходимости и кэшировать их как
 объекты Building/Entity.
 Когда создаём экземпляр объекта на карте, берем/загружаем шаблон
 с названием ${template} и изменяем переопределенные свойства.
 Проблемка в том, что GSON по умолчанию ставит некоторые свойства на
 0 или на false, а они могут быть true в шаблоне, а в экземпляре
 не переопределены - тогда всё печально. Поэтому GSON создаёт экземпляр
 NullableGameObject, где даже примитивные типы являются nullable,
 а затем при объединении с шаблоном получим GameObject.
 - x, y, width, height, isRigid, layer, moveDirection, infoClient - тут все понятно
 - texture, transparentTexture, transparencyRange - тут все сложно.
 По-хорошему эту информацию не нужно хранить в логике. Можно удалить
 эти свойства, а текстуры/анимации загружать во view через when по
 названию шаблона (его мы храним).
 Встает проблема с изменением текстуры/анимации в ходе игры.
 Можно менять свойство infoClient и делать when еще и по нему.
 Но тогда текстуры будут захардкожены.
 Можно прописывать выбор текстуры в скриптах (хороший вариант).
 Тогда при вызове updateDrawer в скрипт будет передан весь объект.
 Скрипт должен будет вернуть текстуру/анимацию/еще что-то, в общем - 
 экземпляр ObjectDrawer. Тогда все тоже будет захардкожено, но уже в
 скрипте (так легче расширять). Из проблем - скрипт будет вызываться
 каждый раз для каждого объекта, но вообще это не проблема, потому
 что скриптов и так куча.
 - scripts - словарь со скриптами, связанными с объектом.
 Ключ - строка, соответствующая некоторому событию, например:
 onTileEntered, onCollision, onAttack и т.д.
 Значение - название скрипта логики, который должен быть выполнен при
 данном событии.
 - health, speed, etc. - всякие свойства Entity, которых нет у Building.
 Тут тоже все понятно.